// use ::signal_hook::iterator::Signals;

// pub type OnSigWinch = dyn Fn(Box<dyn Fn()>) + Send;
// pub type SigCleanup = dyn Fn() + Send;

// pub fn sigwinch() -> (Box<OnSigWinch>, Box<SigCleanup>) {
//     let signals = Signals::new(&[signal_hook::SIGWINCH]).unwrap();
//     let on_winch = {
//         let signals = signals.clone();
//         move |cb: Box<dyn Fn()>| {
//             for signal in signals.forever() {
//                 match signal {
//                     signal_hook::SIGWINCH => cb(),
//                     _ => unreachable!(),
//                 }
//             }
//         }
//     };
//     let cleanup = move || {
//         signals.close();
//     };
//     (Box::new(on_winch), Box::new(cleanup))
// }
